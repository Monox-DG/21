Код представляет собой простую реализацию игры Pong в консоли на языке C.  Вот подробное объяснение кода:


1. Заголовочные файлы:


stdio.h:  Стандартный ввод/вывод (printf, getchar).
stdlib.h:  Стандартные функции (system, exit).
string.h:  Функции для работы со строками (хотя здесь они не используются).
math.h:   Математические функции (здесь не используются, можно убрать).
unistd.h:  Разные функции POSIX, включая usleep (задержка).

2. Макросы:


Эти макросы определяют константы, используемые в игре:


WIDTH: Ширина игрового поля (80 символов).
HEIGHT: Высота игрового поля (25 символов).
PADDLE_WIDTH: Высота ракетки (3 символа).
BALL_SIZE: Размер мяча (1 символ, хотя используется только для обозначения позиции, а не размера).
MAX_SCORE: Максимальное количество очков, необходимых для победы (21).

3. Структуры:


Player:  Представляет игрока.
x: Координата X ракетки игрока (левый край для первого игрока, правый для второго).
y: Координата Y верхнего края ракетки игрока.
score: Количество очков игрока.
Ball: Представляет мяч.
x: Координата X мяча.
y: Координата Y мяча.
vx: Скорость мяча по оси X (1 или -1).  Определяет направление движения по горизонтали.
vy: Скорость мяча по оси Y (1 или -1).  Определяет направление движения по вертикали.

4. Функции:


draw(Player p1, Player p2, Ball ball): Рисует игровое поле в консоли.


system("clear"): Очищает консоль (работает в Unix-подобных системах).  Заменяет весь текст на экране.
Вложенные циклы for перебирают каждую позицию на экране (x и y).
Условные операторы if определяют, что рисовать в каждой позиции:
| для вертикальных границ.
= для горизонтальных границ.
| для ракеток игроков.  Проверяется, находится ли текущая координата y в пределах ракетки игрока.
* для мяча.
 (пробел) для пустых мест.
printf("\n"): Переходит на новую строку после каждой строки игрового поля.
Отображает счет игроков внизу экрана.
update_ball(Ball* ball, Player* p1, Player* p2): Обновляет положение мяча и проверяет столкновения.


ball->x += ball->vx; и ball->y += ball->vy;: Перемещает мяч на основе его скорости.
Проверяет столкновения с верхней и нижней границами (ball->y <= 1 || ball->y >= HEIGHT - 2). Если мяч сталкивается, меняет направление вертикальной скорости (ball->vy = -ball->vy;).
Проверяет столкновения с ракетками игроков.  Если мяч находится на X-координате ракетки и Y-координата мяча находится в пределах высоты ракетки, меняет направление горизонтальной скорости (ball->vx = -ball->vx;).
Проверяет, не вышел ли мяч за левую или правую границы (ball->x <= 1 || ball->x >= WIDTH - 2). Если вышел:
Увеличивает счет игрока, которому засчитано очко.
Возвращает мяч в центр поля.
Устанавливает начальное направление движения мяча по горизонтали.
main():  Основная функция программы.


Инициализирует игроков и мяч, задавая их начальные позиции и счет.
while (p1.score < MAX_SCORE && p2.score < MAX_SCORE): Основной игровой цикл, который продолжается до тех пор, пока один из игроков не наберет MAX_SCORE очков.
draw(p1, p2, ball):  Рисует текущее состояние игры.
printf(...): Запрашивает ввод команды от пользователя.
command = getchar();  Считывает символ команды, введенный пользователем.
getchar();:  Важно!  Считывает и игнорирует символ новой строки (\n), который остается в буфере ввода после нажатия Enter. Если этого не сделать, следующий getchar() сразу же прочитает этот символ новой строки, и игра не будет ждать ввода команды.
switch (command): Обрабатывает ввод пользователя.
A/a: Двигает ракетку первого игрока вверх (если возможно).
Z/z: Двигает ракетку первого игрока вниз (если возможно).
K/k: Двигает ракетку второго игрока вверх (если возможно).
M/m: Двигает ракетку второго игрока вниз (если возможно).
:  Пропускает ход (ничего не делает).
default: Выводит сообщение об ошибке, если введена неверная команда.
update_ball(&ball, &p1, &p2): Обновляет положение мяча.
usleep(10000):  Приостанавливает выполнение программы на 10000 микросекунд (10 миллисекунд). Это нужно, чтобы игра не работала слишком быстро.  Без этой задержки мяч будет двигаться слишком быстро, и играть будет невозможно.  Значение можно изменить, чтобы сделать игру быстрее или медленнее.
После завершения цикла while, определяет победителя и выводит сообщение.
return 0;:  Возвращает 0, показывая, что программа завершилась успешно.

Важные моменты:


Очистка экрана:  system("clear") работает только в Unix-подобных системах (Linux, macOS).  В Windows эта команда не будет работать.  В Windows можно использовать system("cls"), но это делает код менее переносимым.
Ввод: getchar() считывает только один символ за раз.  Для более сложного ввода нужно использовать другие функции (например, fgets для чтения целой строки).  Важно помнить о считывании символа новой строки после каждого ввода.
Задержка:  usleep() используется для управления скоростью игры.  Без задержки игра будет работать слишком быстро.
Логика игры:  Логика столкновений достаточно простая.  Можно добавить больше реализма, учитывая угол столкновения мяча с ракеткой и изменяя скорость мяча в зависимости от этого.
Переносимость: Код не полностью переносимый из-за system("clear") и usleep().

Этот код - отличный пример простой игры, написанной на C.  Он демонстрирует основные принципы работы с вводом/выводом, структурами данных и игровым циклом.
 
Давайте разберем его по частям:

Заголовочные файлы:
stdio.h: для работы с вводом/выводом
stdlib.h: для общих функций
string.h: для работы со строками
math.h: для математических функций
unistd.h: для системных вызовов (usleep)
Макросы (#define):
WIDTH и HEIGHT определяют размеры игрового поля
PADDLE_WIDTH - ширина ракеток
BALL_SIZE - размер мяча
MAX_SCORE - максимальное количество очков для победы
Структуры данных:
Player: содержит координаты и счет игрока
Ball: содержит координаты мяча и векторы скорости
Функция draw():
Очистка экрана
Рисование игрового поля с помощью вложенных циклов
Вывод ракеток, мяча и границ
Отображение счета игроков
Функция update_ball():
Обновление положения мяча
Проверка столкновений с границами и ракетками
Обработка отскоков
Подсчет очков при попадании за границы
Функция main():
Инициализация игроков и мяча
Основной игровой цикл
Обработка команд от игроков (A/Z для первого, K/M для второго)
Обновление положения мяча
Задержка для управления скоростью игры (usleep)
Определение победителя
Особенности реализации:

Игра использует текстовый режим
Управление происходит через консоль
Движение ракеток ограничено игровым полем
Мяч отскакивает от границ и ракеток
Игра заканчивается при достижении MAX_SCORE одним из игроков
Недостатки:

Нет обработки одновременного нажатия клавиш
Простой искусственный интеллект отсутствует
Нет плавности движения (только пошаговое)
Ограниченное управление через консоль
Это хороший пример простой консольной игры на C, демонстрирующий работу с структурами данных, функциями и базовую обработку ввода-вывода.

ещё подробнее
Давайте разберем код еще более детально:

Директивы препроцессора:
#include <stdio.h> // для printf(), getchar()
#include <stdlib.h> // для system()
#include <string.h> // не используется в данном коде
#include <math.h>   // не используется в данном коде
#include <unistd.h> // для usleep()

#define WIDTH 80    // ширина игрового поля
#define HEIGHT 25   // высота игрового поля
#define PADDLE_WIDTH 3 // ширина ракеток
#define BALL_SIZE 1    // размер мяча
#define MAX_SCORE 21   // максимальное количество очков для победы
Структуры данных:
typedef struct {
    int x, y; // координаты
    int score; // счет игрока
} Player;

typedef struct {
    int x, y; // координаты мяча
    int vx, vy; // векторы скорости
} Ball;
Player содержит:
x: фиксированная позиция по горизонтали (1 или WIDTH-2)
y: текущая позиция по вертикали
score: текущий счет
Ball содержит:
x,y: текущие координаты
vx,vy: скорость по осям (могут быть -1 или 1)
Функция draw():
void draw(Player p1, Player p2, Ball ball) {
    system("clear"); // очистка консоли
    
    // Внешний цикл по строкам
    for (int y = 0; y < HEIGHT; y++) {
        // Внутренний цикл по колонкам
        for (int x = 0; x < WIDTH; x++) {
            // Проверка условий для каждого символа:
            if (x == 0 || x == WIDTH - 1) {
                printf("|"); // вертикальные границы
            } else if (y == 0 || y == HEIGHT - 1) {
                printf("="); // горизонтальные границы
            } else if (x == 1 && y >= p1.y && y < p1.y + PADDLE_WIDTH) {
                printf("|"); // левая ракетка
            } else if (x == WIDTH - 2 && y >= p2.y && y < p2.y + PADDLE_WIDTH) {
                printf("|"); // правая ракетка
            } else if (x == ball.x && y == ball.y) {
                printf("*"); // мяч
            } else {
                printf(" "); // пустое место
            }
        }
        printf("\n"); // переход на новую строку
    }
    
    // Вывод счета
    printf("| Player_1 | Score: %d |\n", p1.score);
    printf("| Player_2 | Score: %d |\n", p2.score);
}
Функция update_ball():
void update_ball(Ball* ball, Player* p1, Player* p2) {
    // Обновление положения мяча
    ball->x += ball->vx;
    ball->y += ball->vy;
    
    // Проверка столкновений:
    // С верхней/нижней границей
    if (ball->y <= 1 || ball->y >= HEIGHT - 2) {
        ball->vy = -ball->vy; // изменение направления
    }
    
    // С ракетками
    if (ball->x == 2 && ball->y >= p1->y && ball->y < p1->y + PADDLE_WIDTH) {
        ball->vx = -ball->vx; // отскок от левой ракетки
    } else if (ball->x == WIDTH - 3 && ball->y >= p2->y && ball->y < p2->y + PADDLE_WIDTH) {
        ball->vx = -ball->vx; // отскок от правой ракетки
    }
    
    // Проверка выхода за границы
    if (ball->x <= 1) {
        p2->score++; // очко правому игроку
        ball->x = WIDTH / 2;
        ball->y = HEIGHT / 2;
        ball->vx = 1; // начальная скорость вправо
    } else if (ball->x >= WIDTH - 2) {
        p1->score++; // очко левому игроку
        ball->x = WIDTH / 2;
        ball->y = HEIGHT / 2;
Ещё подробнее
Давайте разберем каждую часть кода максимально подробно:

Основные директивы препроцессора:
#include <stdio.h> // для работы с вводом/выводом (printf, scanf, getchar)
#include <stdlib.h> // для системных функций (system, exit)
#include <string.h> // для работы со строками (не используется в этом коде)
#include <math.h> // для математических функций (не используется в этом коде)
#include <unistd.h> // для функции задержки usleep

// Макросы для констант
#define WIDTH 80 // ширина игрового поля
#define HEIGHT 25 // высота игрового поля
#define PADDLE_WIDTH 3 // ширина ракеток
#define BALL_SIZE 1 // размер мяча
#define MAX_SCORE 21 // максимальное количество очков для победы
Структуры данных:
typedef struct {
    int x, y; // координаты игрока
    int score; // текущий счет
} Player;

typedef struct {
    int x, y; // текущие координаты мяча
    int vx, vy; // векторы скорости мяча
} Ball;
Player содержит:
x: фиксированная позиция по горизонтали (1 или WIDTH-2)
y: текущая позиция по вертикали
score: текущий счет игрока
Ball содержит:
x,y: текущие координаты мяча
vx,vy: векторы скорости (могут быть -1 или 1)
Функция draw():
void draw(Player p1, Player p2, Ball ball) {
    system("clear"); // очистка консоли
    
    // Внешний цикл по строкам
    for (int y = 0; y < HEIGHT; y++) {
        // Внутренний цикл по колонкам
        for (int x = 0; x < WIDTH; x++) {
            // Проверка условий для каждого символа:
            if (x == 0 || x == WIDTH - 1) {
                printf("|"); // вертикальные границы
            } else if (y == 0 || y == HEIGHT - 1) {
                printf("="); // горизонтальные границы
            } else if (x == 1 && y >= p1.y && y < p1.y + PADDLE_WIDTH) {
                printf("|"); // левая ракетка
            } else if (x == WIDTH - 2 && y >= p2.y && y < p2.y + PADDLE_WIDTH) {
                printf("|"); // правая ракетка
            } else if (x == ball.x && y == ball.y) {
                printf("*"); // мяч
            } else {
                printf(" "); // пустое место
            }
        }
        printf("\n"); // переход на новую строку
    }
    
    // Вывод счета
    printf("| Player_1 | Score: %d |\n", p1.score);
    printf("| Player_2 | Score: %d |\n", p2.score);
}
Функция update_ball():
void update_ball(Ball* ball, Player* p1, Player* p2) {
    // Обновление положения мяча
    ball->x += ball->vx;
    ball->y += ball->vy;
    
    // Проверка столкновений:
    // С верхней/нижней границей
    if (ball->y <= 1 || ball->y >= HEIGHT - 2) {
        ball->vy = -ball->vy; // изменение направления
    }
    
    // С ракетками
    if (ball->x == 2 && ball->y >= p1->y && ball->y < p1->y + PADDLE_WIDTH) {
        ball->vx = -ball->vx; // отскок от левой ракетки
    } else if (ball->x == WIDTH - 3 && ball->y >= p2->y && ball->y < p2->y + PADDLE_WIDTH) {
        ball->vx = -ball->vx; // отскок от правой ракетки
    }
    
    // Проверка выхода за границы
    if (ball->x <= 1) {
        p2->score++; // очко правому игроку
        ball->x = WIDTH / 2;
        ball->y = HEIGHT / 2;
        ball->vx = 1; // начальная скорость вправо
    } else if (ball->x >= WIDTH - 2)

Давайте разберем функцию main() подробно:

Инициализация:
Player p1 = { 1, HEIGHT / 2 - 1, 0 }; // игрок 1
Player p2 = { WIDTH - 2, HEIGHT / 2 - 1, 0 }; // игрок 2
Ball ball = { WIDTH / 2, HEIGHT / 2, 1, 1 }; // мяч
Игрок 1 (p1):
x = 1 (крайняя левая позиция)
y = HEIGHT/2 - 1 (посередине поля)
score = 0
Игрок 2 (p2):
x = WIDTH - 2 (крайняя правая позиция)
y = HEIGHT/2 - 1 (посередине поля)
score = 0
Мяч (ball):
x = WIDTH/2 (в центре по горизонтали)
y = HEIGHT/2 (в центре по вертикали)
vx = 1 (движется вправо)
vy = 1 (движется вниз)
Основной игровой цикл:
while (p1.score < MAX_SCORE && p2.score < MAX_SCORE) {
    // ...
}
Цикл продолжается, пока ни один из игроков не набрал MAX_SCORE (21 очко)
Обработка ввода:
printf("Press A/Z for Player 1, K/M for Player 2, Space to step: ");
command = getchar();
Программа выводит подсказку с доступными командами
getchar() считывает один символ с клавиатуры
Обработка команд через switch:
switch (command) {
    case 'A':
    case 'a':
        if (p1.y > 1) p1.y--; // движение вверх
        break;
    // ... и так далее для всех команд
}
Команды для игрока 1 (p1):
A/a: движение вверх (если не уперся в верхнюю границу)
Z/z: движение вниз (если не уперся в нижнюю границу)
Команды для игрока 2 (p2):
K/k: движение вверх
M/m: движение вниз
Пробел: пропускает ход (просто обновляет состояние игры)
Любые другие символы: выводятся сообщение об ошибке
Обновление состояния игры:
update_ball(&ball, &p1, &p2);
usleep(10000); // задержка 10000 микросекунд (10 мс)
update_ball() обновляет положение мяча и проверяет столкновения
usleep() добавляет задержку для контроля скорости игры
Определение победителя:
if (p1.score >= MAX_SCORE) {
    printf("Player 1 Wins!\n");
} else if (p2.score >= MAX_SCORE) {
    printf("Player 2 Wins!\n");
}
После выхода из цикла проверяется, кто набрал больше очков
Выводится соответствующее сообщение о победе
Особенности реализации:

Игра использует текстовый режим
Управление происходит через консоль
Движение ракеток ограничено игровым полем
Мяч отскакивает от границ и ракеток
Игра заканчивается при достижении MAX_SCORE одним из игроков
Недостатки:

Нет обработки одновременного нажатия клавиш
Простой искусственный интеллект отсутствует
Нет плавности движения (только пошаговое)
Ограниченное управление через консоль
Это хороший пример простой консольной игры на C, демонстрирующий работу с структурами данных, функциями и базовую обработку ввода-вывода.

ещё подробнее
Давайте разберем каждый аспект функции main() максимально подробно:

Инициализация переменных:
Player p1 = { 1, HEIGHT / 2 - 1, 0 }; // игрок 1
Player p2 = { WIDTH - 2, HEIGHT / 2 - 1, 0 }; // игрок 2
Ball ball = { WIDTH / 2, HEIGHT / 2, 1, 1 }; // мяч
Игрок 1 (p1):
x = 1 (крайняя левая позиция, фиксированная)
y = HEIGHT/2 - 1 (в центре поля по вертикали)
score = 0 (начальный счет)
Игрок 2 (p2):
x = WIDTH - 2 (крайняя правая позиция, фиксированная)
y = HEIGHT/2 - 1 (в центре поля по вертикали)
score = 0 (начальный счет)
Мяч (ball):
x = WIDTH/2 (в центре поля по горизонтали)
y = HEIGHT/2 (в центре поля по вертикали)
vx = 1 (начальная скорость по горизонтали вправо)
vy = 1 (начальная скорость по вертикали вниз)
Основной игровой цикл:
while (p1.score < MAX_SCORE && p2.score < MAX_SCORE) {
    // игровой код
}
Цикл продолжается, пока ни один из игроков не набрал 21 очко
MAX_SCORE = 21 (определено через #define)
Цикл выполняется до тех пор, пока условие истинно
Визуализация игрового состояния:
draw(p1, p2, ball);
Вызывает функцию draw() для отрисовки игрового поля
Передает текущие позиции игроков и мяча
Очистка экрана и отрисовка всех элементов
Обработка пользовательского ввода:
printf("Press A/Z for Player 1, K/M for Player 2, Space to step: ");
command = getchar();
Выводит подсказку с доступными командами
getchar() считывает один символ с клавиатуры
Считывает только первый символ из буфера ввода
Обработка команд через switch:
switch (command) {
    case 'A':
    case 'a':
        if (p1.y > 1) p1.y--; // движение вверх
        break;
    //... и так далее для всех команд
}
Команды для игрока 1 (p1):
A/a: движение вверх (если не уперся в верхнюю границу)
Z/z: движение вниз (если не уперся в нижнюю границу)
Команды для игрока 2 (p2):
K/k: движение вверх
M/m: движение вниз
Пробел: пропускает ход (просто обновляет состояние игры)
Любые другие символы: выводятся сообщение об ошибке
Проверка границ для движения:
Для p1.y:
Верхняя граница: p1.y > 1
Нижняя граница: p1.y < HEIGHT - PADDLE_WIDTH - 1
Для p2.y:
Верхняя граница: p2.y > 1
Нижняя граница: p2.y < HEIGHT - PADDLE_WIDTH - 1
Обновление игрового состояния:
update_ball(&ball, &p1, &p2);
usleep(10000); // задержка 10000 микросекунд (10 мс)
update_ball() обновляет:
Положение мяча
Проверяет столкновения с границами
Проверяет столкновения с ракетками
Обновляет счет при попадании за границы
usleep() добавляет задержку:
10000 микросекунд = 10 миллисекунд
Контролирует скорость движения мяча
Предотвращает слишком быстрое движение
Определение победителя:
if (p1.score >= MAX_SCORE) {
    printf("Player 1 Wins!\n");
} else if (p2.score >= MAX_SCORE) {
    printf("Player 2 Wins!\n");
}
Проверяет, кто первым достиг 21 очка
Выводит соответствующее сообщение
Завершает игру
Особенности реализации:
Текстовый режим отображения
Консольное управление

Давайте подробно рассмотрим все функции и их работу:

Функция draw():
void draw(Player p1, Player p2, Ball ball) {
    system("clear"); // очищаем экран
    
    // рисуем поле
    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            // Проверка условий для каждого символа:
            if (x == 0 || x == WIDTH - 1) {
                printf("|"); // вертикальные границы
            } else if (y == 0 || y == HEIGHT - 1) {
                printf("="); // горизонтальные границы
            } else if (x == 1 && y >= p1.y && y < p1.y + PADDLE_WIDTH) {
                printf("|"); // левая ракетка
            } else if (x == WIDTH - 2 && y >= p2.y && y < p2.y + PADDLE_WIDTH) {
                printf("|"); // правая ракетка
            } else if (x == ball.x && y == ball.y) {
                printf("*"); // мяч
            } else {
                printf(" "); // пустое место
            }
        }
        printf("\n"); // переход на новую строку
    }
    
    // Вывод счета
    printf("| Player_1 | Score: %d |\n", p1.score);
    printf("| Player_2 | Score: %d |\n", p2.score);
}
Функция update_ball():
void update_ball(Ball* ball, Player* p1, Player* p2) {
    // Обновление положения мяча
    ball->x += ball->vx;
    ball->y += ball->vy;
    
    // Проверка столкновений:
    // С верхней/нижней границей
    if (ball->y <= 1 || ball->y >= HEIGHT - 2) {
        ball->vy = -ball->vy; // изменение направления
    }
    
    // С ракетками
    if (ball->x == 2 && ball->y >= p1->y && ball->y < p1->y + PADDLE_WIDTH) {
        ball->vx = -ball->vx; // отскок от левой ракетки
    } else if (ball->x == WIDTH - 3 && ball->y >= p2->y && ball->y < p2->y + PADDLE_WIDTH) {
        ball->vx = -ball->vx; // отскок от правой ракетки
    }
    
    // Проверка выхода за границы
    if (ball->x <= 1) {
        p2->score++; // очко правому игроку
        ball->x = WIDTH / 2;
        ball->y = HEIGHT / 2;
        ball->vx = 1; // начальная скорость вправо
    } else if (ball->x >= WIDTH - 2) {
        p1->score++; // очко левому игроку
        ball->x = WIDTH / 2;
        ball->y = HEIGHT / 2;
        ball->vx = -1; // начальная скорость влево
    }
}
Функция main():
int main() {
    // Инициализация игроков и мяча
    Player p1 = { 1, HEIGHT / 2 - 1, 0 }; // игрок 1
    Player p2 = { WIDTH - 2, HEIGHT / 2 - 1, 0 }; // игрок 2
    Ball ball = { WIDTH / 2, HEIGHT / 2, 1, 1 }; // мяч
    
    char command;
    while (p1.score < MAX_SCORE && p2.score < MAX_SCORE) {
        draw(p1, p2, ball);
        printf("Press A/Z for Player 1, K/M for Player 2, Space to step: ");
        command = getchar(); // игнорируем ввод новой строки
        
        switch (command) {
            case 'A':
            case 'a':
                if (p1.y > 1) p1.y--; // движение вверх
                break;
            case 'Z':
            case 'z':
                if (p1.y < HEIGHT - PADDLE_WIDTH - 1) p1.y++; // движение вниз
                break;
            case 'K':
            case 'k':

Давайте подробно рассмотрим все используемые библиотеки и их функции:

<stdlib.h>
Основная библиотека для стандартных функций общего назначения
Содержит функции для:
управления памятью
преобразования строк
генерации случайных чисел
работы с процессами
В программе используется функция system() для очистки экрана
system() выполняет командную строку операционной системы
Позволяет выполнять системные команды напрямую
<string.h>
Библиотека для работы со строками
Содержит функции для:
копирования строк (strcpy())
сравнения строк (strcmp())
поиска подстрок (strstr())
работы с памятью (memset(), memcpy())
В данной программе напрямую не используется
<math.h>
Библиотека математических функций
Содержит функции для:
тригонометрических вычислений
экспоненциальных функций
логарифмов
округления чисел
В данной программе напрямую не используется
<unistd.h>
Библиотека для POSIX-совместимых систем
Содержит функции для:
работы с файловым вводом-выводом
управления процессами
работы с терминалом
В программе используется функция usleep()
usleep() приостанавливает выполнение на заданное количество микросекунд
Используется для контроля скорости игры
Принцип работы используемых функций:

system(“clear”):
Вызывает системную команду clear
Очищает терминал от предыдущего вывода
Используется для перерисовки игрового поля
usleep(10000):
Приостанавливает выполнение на 10000 микросекунд (10 мс)
Контролирует скорость движения мяча
Создает задержку между обновлениями
Особенности использования:

system() может быть платформозависимой функцией
usleep() является частью POSIX стандарта
Задержка в 10 мс обеспечивает комфортную скорость игры
Очистка экрана необходима для корректного перерисовывания игрового поля



